# vk_trainee

# Задание
Необходимо написать код, который эффективным образом найдёт количество общих элементов в двух массивах int-ов. Можно считать, что элементы внутри каждого массива не повторяются. Уделите внимание случаю, когда один список намного меньше другого по размеру. Кроме того, необходимо написать код, который тестирует правильность алгоритма. 

Что будет оцениваться: 
1. Правильность работы алгоритма. 
2. Скорость работы. Важна не только асимптотика, но и скрытая в ней константа. 
3. Полнота тестов. Неправильно написанный алгоритм не должен проходить ваш тест. 
4. Читаемость кода. 

# Решение
Пусть есть два массива длины S, L, где 1<=S<=L<=MAX_INT
Надо найти количество повторяющихся элементов.

## Вариант 1
Делаем Hash (unordered_set) из меньшего массива, затем идём по большему массиву и проверяем есть ли данные элементы в hash.
Асимптотика работы алгоритма будет O(L) так как нам останется пройти по второму массиву и проверить есть ли эти элементы в ХэшТаблице. Если будет не много коллизий, то алгоритм теоретически должен работать быстро, особенно если S мало.
Но на практике оказалось не так.
## Вариант 2
Если отсортировать оба массива и указателями пройтись от самых маленьких элементов к большим, то мы сможем узнать есть ли одинаковые элементы.
Делаем два указателя на первые элементы каждого массива. Если значения указателей равны, то counter++, и идём дальше. Если значения указателей не равны, то меньший из них увеличиваем на единицу.
Асимптотика работы алгоритма: сортировка + проход. Проход в любом случае O(S+L) ~ O(2L).
Теоретически поразрядная сортировка должна дать O(10\*S+10\*L).
Любая простая сортировка std::sort даёт O(K\*n\*log(n)), где K некая константа. А log(n) можно ограничить сверху 32 так как числа int. И чуть получше вариант quick_sort где коэффициент и основание логарифма будут меньше.

# Тесты
Простые тесты для проверки работоспособности алгоритмов. Ограничения взятые по умолчанию. Размеры не могут быть меньше 1.
И сложные генерённые тесты для разных размеров входящих данных. Сравнение времени работы всех алгоритмов.
На практике получилось, что даже при маленьких S второй вариант с quick_sort работает быстрее. Затем hash и после все остальные варианты.
при примерно одинаковых значениях S и L второй вариант с quick_sort работает быстрее. Затем std::sort затем все остальные.

# Ответ
После тестирования на разных данных лучше всего использовать quick_sort
